<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATAS Database Management</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
    <style>
        /* Critical: Prevent white flash during initial load and scroll */
        html, body {
            background-color: #020617 !important;
        }
        body {
            background: linear-gradient(to bottom right, #020617, #0f172a, #1e293b, #0f172a) !important;
            background-attachment: fixed !important;
        }
    </style>
</head>
<body>

    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <div class="brand">
                    <div class="brand-icon">
                        <svg class="icon" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                            <!-- Background Circle -->
                            <circle cx="100" cy="100" r="95" fill="#0066FF" opacity="0.1"/>
                            <circle cx="100" cy="100" r="85" fill="#0066FF" opacity="0.2"/>
                            
                            <!-- Main Circle Background -->
                            <circle cx="100" cy="100" r="75" fill="url(#gradient1)"/>
                            
                            <!-- Gradient Definitions -->
                            <defs>
                                <linearGradient id="gradient1" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#0066FF;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#0099FF;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="gradient2" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#00CC88;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#00FF99;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            
                            <!-- Testing Symbol - Checkmark in Shield -->
                            <path d="M 100 40 L 130 55 L 130 90 Q 130 110 100 125 Q 70 110 70 90 L 70 55 Z" 
                                  fill="white" opacity="0.9"/>
                            
                            <!-- Checkmark -->
                            <path d="M 85 80 L 95 92 L 115 65" 
                                  stroke="url(#gradient2)" 
                                  stroke-width="6" 
                                  fill="none" 
                                  stroke-linecap="round" 
                                  stroke-linejoin="round"/>
                            
                            <!-- Service Cloud Symbols (3 nodes representing distributed testing) -->
                            <circle cx="65" cy="145" r="10" fill="white" opacity="0.9"/>
                            <circle cx="100" cy="155" r="10" fill="white" opacity="0.9"/>
                            <circle cx="135" cy="145" r="10" fill="white" opacity="0.9"/>
                            
                            <!-- Connection Lines -->
                            <line x1="65" y1="145" x2="100" y2="155" stroke="white" stroke-width="2" opacity="0.7"/>
                            <line x1="100" y1="155" x2="135" y2="145" stroke="white" stroke-width="2" opacity="0.7"/>
                            <line x1="65" y1="145" x2="135" y2="145" stroke="white" stroke-width="2" opacity="0.7"/>
                            
                            <!-- Letter M (subtle, integrated) -->
                            <text x="100" y="108" font-family="Arial, sans-serif" font-size="32" font-weight="bold" 
                                  fill="url(#gradient2)" text-anchor="middle" opacity="0.3">M</text>
                            
                            <!-- Small accent dots for tech feel -->
                            <circle cx="45" cy="70" r="3" fill="white" opacity="0.5"/>
                            <circle cx="155" cy="70" r="3" fill="white" opacity="0.5"/>
                            <circle cx="50" cy="120" r="2" fill="white" opacity="0.4"/>
                            <circle cx="150" cy="120" r="2" fill="white" opacity="0.4"/>
                        </svg>
                    </div>
                    <h1 class="header-title" data-text="ATAS Database Management">ATAS Database Management</h1>
                </div>
                <p class="header-subtitle">Real-time operational metrics and data exploration</p>
            </div>
            <div class="header-right">
                <div class="system-status">
                    <div class="status-dot"></div>
                    <span>System Operational</span>
                </div>
            </div>
        </header>

        <!-- Controls -->
        <div class="controls-bar">
            <div class="auto-refresh-group">
                <div class="dropdown auto-refresh-dropdown">
                    <select id="auto-refresh-select" class="refresh-select" onchange="updateAutoRefresh()">
                        <option value="0">Manual Refresh</option>
                        <option value="5000">5s</option>
                        <option value="10000" selected>10s</option>
                        <option value="30000">30s</option>
                        <option value="60000">1m</option>
                    </select>
                    <button type="button" class="dropdown-trigger" id="refresh-dropdown-trigger" aria-haspopup="true" aria-expanded="false" onclick="toggleDropdown(this)" onkeydown="handleDropdownKeydown(event, this)">
                        <span id="refresh-dropdown-text">10s</span>
                        <svg class="icon" viewBox="0 0 24 24" style="width: 16px; height: 16px; stroke: currentColor; stroke-width: 2; fill: none;">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </button>
                    <div class="dropdown-menu" id="refresh-dropdown-menu" role="menu">
                        <div class="dropdown-option selected" role="menuitem" tabindex="0" data-value="10000" onclick="selectRefreshOption(10000)" onkeydown="handleDropdownOptionKeydown(event, 10000)">10s</div>
                        <div class="dropdown-option" role="menuitem" tabindex="0" data-value="0" onclick="selectRefreshOption(0)" onkeydown="handleDropdownOptionKeydown(event, 0)">Manual Refresh</div>
                        <div class="dropdown-option" role="menuitem" tabindex="0" data-value="5000" onclick="selectRefreshOption(5000)" onkeydown="handleDropdownOptionKeydown(event, 5000)">5s</div>
                        <div class="dropdown-option" role="menuitem" tabindex="0" data-value="30000" onclick="selectRefreshOption(30000)" onkeydown="handleDropdownOptionKeydown(event, 30000)">30s</div>
                        <div class="dropdown-option" role="menuitem" tabindex="0" data-value="60000" onclick="selectRefreshOption(60000)" onkeydown="handleDropdownOptionKeydown(event, 60000)">1m</div>
                    </div>
                </div>
                <div id="refresh-countdown" class="refresh-countdown">10</div>
            </div>
            
            <div class="action-buttons-group">
                <button class="action-btn btn-primary" onclick="window.location.href = '/monitoring/dashboard'">
                    <svg class="icon" viewBox="0 0 24 24">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="9" y1="21" x2="9" y2="9"/>
                    </svg>
                    <span>Test Dashboard</span>
                </button>
            </div>
        </div>

        <!-- Stats Grid -->
        <div class="grid">
            <!-- Health Overview -->
            <div class="card spotlight-card col-span-12">
                <div class="card-header">
                    <span class="card-title">
                        <span class="card-icon">
                            <svg class="icon" viewBox="0 0 24 24"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>
                        </span>
                        System Health
                    </span>
                </div>
                <div class="metrics-grid" id="database-health-overview">
                    <div class="loading-overlay"><div class="spinner"></div> Loading health metrics...</div>
                </div>
            </div>

            <!-- Operations -->
            <div class="card spotlight-card col-span-6">
                <div class="card-header">
                    <span class="card-title">
                        <span class="card-icon">
                            <svg class="icon" viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
                        </span>
                        Live Operations
                    </span>
                </div>
                <div class="metrics-grid" id="real-time-operations">
                    <div class="loading-overlay"><div class="spinner"></div> Loading operations...</div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="card spotlight-card col-span-6">
                <div class="card-header">
                    <span class="card-title">
                        <span class="card-icon">
                            <svg class="icon" viewBox="0 0 24 24"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>
                        </span>
                        Database Stats
                    </span>
                </div>
                <div class="metrics-grid" id="database-statistics">
                    <div class="loading-overlay"><div class="spinner"></div> Loading statistics...</div>
                </div>
            </div>

            <!-- Chart -->
            <div class="card spotlight-card col-span-12">
                <div class="card-header">
                    <span class="card-title">
                        <span class="card-icon">
                            <svg class="icon" viewBox="0 0 24 24"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>
                        </span>
                        Data Distribution
                    </span>
                </div>
                <div class="distribution-wrapper">
                    <div class="distribution-chart-section">
                        <div class="distribution-chart-container" id="db-chart-container">
                            <div class="distribution-center-content">
                                <div class="distribution-total" id="db-distribution-total">0</div>
                                <div class="distribution-label">Total Records</div>
                            </div>
                            <canvas id="tableStatisticsChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Executions Table -->
            <div class="card spotlight-card col-span-12">
                <div class="card-header">
                    <span class="card-title">
                        <span class="card-icon">
                            <svg class="icon" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                        </span>
                        Test Executions
                    </span>
                </div>
                <div class="filters-bar">
                    <div class="filters-left">
                        <input type="text" id="filter-execution-id" class="filter-input" placeholder="Filter by Execution ID...">
                        <input type="text" id="filter-suite-name" class="filter-input" placeholder="Filter by Suite...">
                        <div class="dropdown">
                            <select id="filter-execution-status" class="refresh-select" onchange="applyExecutionFilters()">
                                <option value="">All Statuses</option>
                                <option value="PASSED">Passed</option>
                                <option value="FAILED">Failed</option>
                                <option value="RUNNING">Running</option>
                            </select>
                            <button type="button" class="dropdown-trigger" id="filter-execution-status-trigger" onclick="toggleDropdown(this)">
                                <span id="filter-execution-status-text">All Statuses</span>
                                <svg class="icon" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </button>
                            <div class="dropdown-menu" id="filter-execution-status-menu">
                                <div class="dropdown-option selected" data-value="" onclick="selectFilterOption('execution-status', '')">All Statuses</div>
                                <div class="dropdown-option" data-value="PASSED" onclick="selectFilterOption('execution-status', 'PASSED')">Passed</div>
                                <div class="dropdown-option" data-value="FAILED" onclick="selectFilterOption('execution-status', 'FAILED')">Failed</div>
                                <div class="dropdown-option" data-value="RUNNING" onclick="selectFilterOption('execution-status', 'RUNNING')">Running</div>
                            </div>
                        </div>
                    </div>
                    <button class="btn-reset" onclick="clearExecutionFilters()">
                        <svg class="icon" viewBox="0 0 24 24">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                        Reset
                    </button>
                </div>
                <div class="table-wrapper">
                    <div style="padding: 12px 16px; background: rgba(245, 158, 11, 0.1); border-bottom: 1px solid rgba(245, 158, 11, 0.3); color: var(--accent-warning); font-size: 12px; display: flex; align-items: center; gap: 8px;">
                        <svg class="icon" viewBox="0 0 24 24" style="width: 16px; height: 16px;">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="16" x2="12" y2="12"/>
                            <line x1="12" y1="8" x2="12.01" y2="8"/>
                        </svg>
                        <span>Data loads automatically as you scroll. Use filters to search within loaded records.</span>
                    </div>
                    <table id="executions-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Execution ID</th>
                                <th>Suite</th>
                                <th>Status</th>
                                <th>Env</th>
                                <th>Duration</th>
                                <th>Time</th>
                                <th>Results</th>
                                <th class="text-right">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
                <div class="pagination" id="executions-pagination"></div>
            </div>

            <!-- Results Table -->
            <div class="card spotlight-card col-span-12">
                <div class="card-header">
                    <span class="card-title">
                        <span class="card-icon">
                            <svg class="icon" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                        </span>
                        Granular Results
                    </span>
                </div>
                <div class="filters-bar">
                    <div class="filters-left">
                        <input type="text" id="filter-test-name" class="filter-input" placeholder="Search Test Name...">
                        <div class="dropdown">
                            <select id="filter-result-status" class="refresh-select" onchange="applyResultFilters()">
                                <option value="">All Statuses</option>
                                <option value="PASSED">Passed</option>
                                <option value="FAILED">Failed</option>
                            </select>
                            <button type="button" class="dropdown-trigger" id="filter-result-status-trigger" onclick="toggleDropdown(this)">
                                <span id="filter-result-status-text">All Statuses</span>
                                <svg class="icon" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </button>
                            <div class="dropdown-menu" id="filter-result-status-menu">
                                <div class="dropdown-option selected" data-value="" onclick="selectFilterOption('result-status', '')">All Statuses</div>
                                <div class="dropdown-option" data-value="PASSED" onclick="selectFilterOption('result-status', 'PASSED')">Passed</div>
                                <div class="dropdown-option" data-value="FAILED" onclick="selectFilterOption('result-status', 'FAILED')">Failed</div>
                            </div>
                        </div>
                    </div>
                    <button class="btn-reset" onclick="clearResultFilters()">
                        <svg class="icon" viewBox="0 0 24 24">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                        Reset
                    </button>
                </div>
                <div class="table-wrapper">
                    <table id="results-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Test Name</th>
                                <th>Execution</th>
                                <th>Status</th>
                                <th>Duration</th>
                                <th>Steps</th>
                                <th>Time</th>
                                <th class="text-right">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
                <div class="pagination" id="results-pagination"></div>
            </div>
        </div>
    </div>

    <!-- Test Result JSON Modal - Global Overlay at Document Root -->
    <div id="json-modal-overlay" class="json-modal-overlay" onclick="closeJsonModal(event)">
        <div class="json-modal" onclick="event.stopPropagation()">
            <div class="json-modal-header">
                <div class="json-modal-title">
                    <svg class="icon" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                    </svg>
                    <span>Test Result JSON</span>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <button class="action-btn btn-small" onclick="copyJson()" style="padding: 6px 12px; font-size: 12px;">
                        <svg class="icon" viewBox="0 0 24 24" style="width: 14px; height: 14px;">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                        </svg>
                        Copy
                    </button>
                    <button class="json-modal-close" onclick="closeJsonModal()">
                        <svg class="icon" viewBox="0 0 24 24" style="width: 18px; height: 18px;">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="json-modal-body">
                <div id="json-modal-content" class="json-loading">Loading JSON data...</div>
            </div>
        </div>
    </div>

    <!-- Custom Confirmation Dialog -->
    <div id="confirm-dialog-overlay" class="confirm-dialog-overlay" onclick="closeConfirmDialog(event)">
        <div class="confirm-dialog" onclick="event.stopPropagation()">
            <div class="confirm-dialog-header">
                <div class="confirm-dialog-title">
                    <svg class="icon" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    <span id="confirm-dialog-title-text">Confirm Action</span>
                </div>
            </div>
            <div class="confirm-dialog-body">
                <p id="confirm-dialog-message">Are you sure you want to proceed?</p>
            </div>
            <div class="confirm-dialog-footer">
                <button class="action-btn btn-secondary" onclick="closeConfirmDialog()" id="confirm-dialog-cancel">
                    Cancel
                </button>
                <button class="action-btn btn-danger" onclick="confirmDialogAction()" id="confirm-dialog-confirm">
                    Confirm
                </button>
            </div>
        </div>
    </div>

    <!-- Custom Alert Dialog -->
    <div id="alert-dialog-overlay" class="confirm-dialog-overlay" onclick="closeAlertDialog(event)">
        <div class="confirm-dialog" onclick="event.stopPropagation()">
            <div class="confirm-dialog-header">
                <div class="confirm-dialog-title">
                    <svg class="icon" viewBox="0 0 24 24" style="width: 20px; height: 20px;">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    <span id="alert-dialog-title-text">Alert</span>
                </div>
                <button class="json-modal-close" onclick="closeAlertDialog()">
                    <svg class="icon" viewBox="0 0 24 24" style="width: 18px; height: 18px;">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="confirm-dialog-body">
                <p id="alert-dialog-message"></p>
            </div>
            <div class="confirm-dialog-footer">
                <button class="action-btn btn-primary" onclick="closeAlertDialog()" id="alert-dialog-ok" style="width: 100%;">
                    OK
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { getAuthToken, redirectToLogin, isAuthenticated } from '/js/core/auth.js';
        import { authenticatedFetch, parseJsonResponse } from '/js/core/api.js';
        import { pollingManager } from '/js/components/polling.js';
        import { initializeAllSpotlightCards } from '/js/components/spotlight.js';
        import { escapeHtml, debounce } from '/js/utils/dom.js';
        import { createDistributionGradients, destroyChart, calculateSpiderLabelOffsets } from '/js/components/charts.js';
        import { config } from '/js/config.js';

        // Auth check
        if (!isAuthenticated()) {
            redirectToLogin();
            throw new Error('Not authenticated');
        }

        // State
        let currentPage = 0, currentResultsPage = 0;
        let totalPages = 0, totalResultsPages = 0;
        let refreshInterval = null, countdownInterval = null;
        
        // Initialize spotlight cards
        document.addEventListener('DOMContentLoaded', () => {
            initializeAllSpotlightCards();
        });
        
        // Hook into visibility changes - pause polling when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('Tab hidden: Pausing real-time updates to save resources.');
                pollingManager.stopAll();
                if (refreshInterval) clearInterval(refreshInterval);
                if (countdownInterval) clearInterval(countdownInterval);
            } else {
                console.log('Tab active: Resuming updates.');
                updateAutoRefresh();
            }
        });
        let tableStatisticsChart = null;
        let allExecutionsData = [], allResultsData = [];
        let isFirstChartLoad = true;
        let isLoadingExecutions = false, isLoadingResults = false;
        let loadExecutionsTimestamp = 0, loadResultsTimestamp = 0;
        
        // Pagination state for API-based virtual scrolling
        let executionsPage = 0;
        let resultsPage = 0;
        const pageSize = 50; // Load 50 items per page
        let executionsHasMore = true;
        let resultsHasMore = true;
        let executionsTotalPages = 0;
        let resultsTotalPages = 0;
        
        // Guard flag to prevent overlapping refresh requests
        let isFetching = false;
        
        // debounce imported from utils/dom.js
        // Spotlight cards initialized via import in DOMContentLoaded

        // Sparkline Chart Helper
        function createSparklineChart(canvasId, data, color) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !data || data.length === 0) return null;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width || canvas.offsetWidth || 200;
            const height = canvas.height || canvas.offsetHeight || 48;
            
            canvas.width = width;
            canvas.height = height;
            
            const padding = 4;
            const chartWidth = width - (padding * 2);
            const chartHeight = height - (padding * 2);
            
            const max = Math.max(...data);
            const min = Math.min(...data);
            const range = max - min || 1;
            
            ctx.clearRect(0, 0, width, height);
            
            // Create gradient
            const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, 'transparent');
            
            // Draw area
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            
            data.forEach((value, index) => {
                const x = padding + (index / (data.length - 1)) * chartWidth;
                const y = height - padding - ((value - min) / range) * chartHeight;
                ctx.lineTo(x, y);
            });
            
            ctx.lineTo(width - padding, height - padding);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw line
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            data.forEach((value, index) => {
                const x = padding + (index / (data.length - 1)) * chartWidth;
                const y = height - padding - ((value - min) / range) * chartHeight;
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            return { canvas, ctx };
        }

        // Initialization
        document.addEventListener('DOMContentLoaded', function() {
            // Auth already checked at module level, spotlight cards already initialized
            initializeCustomDropdown();
            initializeFilterDropdowns();
            
            // Initialize infinite scroll for tables
            const executionsWrapper = document.querySelector('#executions-table')?.closest('.table-wrapper');
            const resultsWrapper = document.querySelector('#results-table')?.closest('.table-wrapper');
            
            if (executionsWrapper) {
                executionsWrapper.addEventListener('scroll', debounce(() => {
                    const scrollTop = executionsWrapper.scrollTop;
                    const scrollHeight = executionsWrapper.scrollHeight;
                    const clientHeight = executionsWrapper.clientHeight;
                    
                    // Load more when scrolled to 80% of the content
                    if (scrollTop + clientHeight >= scrollHeight * 0.8 && executionsHasMore && !isLoadingExecutions) {
                        loadMoreExecutions();
                    }
                }, 200), { passive: true });
            }
            
            if (resultsWrapper) {
                resultsWrapper.addEventListener('scroll', debounce(() => {
                    const scrollTop = resultsWrapper.scrollTop;
                    const scrollHeight = resultsWrapper.scrollHeight;
                    const clientHeight = resultsWrapper.clientHeight;
                    
                    // Load more when scrolled to 80% of the content
                    if (scrollTop + clientHeight >= scrollHeight * 0.8 && resultsHasMore && !isLoadingResults) {
                        loadMoreResults();
                    }
                }, 200), { passive: true });
            }
            
            refreshDatabaseData();
            updateAutoRefresh();
            
            // Attach debounced filter handlers
            const filterExecutionId = document.getElementById('filter-execution-id');
            const filterSuiteName = document.getElementById('filter-suite-name');
            const filterTestName = document.getElementById('filter-test-name');
            
            if (filterExecutionId) {
                filterExecutionId.addEventListener('input', debounce(applyExecutionFilters, 300));
            }
            if (filterSuiteName) {
                filterSuiteName.addEventListener('input', debounce(applyExecutionFilters, 300));
            }
            if (filterTestName) {
                filterTestName.addEventListener('input', debounce(applyResultFilters, 300));
            }
        });

        function initializeCustomDropdown() {
            const select = document.getElementById('auto-refresh-select');
            const trigger = document.getElementById('refresh-dropdown-trigger');
            const menu = document.getElementById('refresh-dropdown-menu');
            if (select && trigger && menu) {
                // Restore saved refresh interval from localStorage
                const savedInterval = localStorage.getItem('autoRefreshInterval');
                if (savedInterval) {
                    const intervalValue = parseInt(savedInterval, 10);
                    if (!isNaN(intervalValue)) {
                        select.value = intervalValue;
                    }
                }
                
                const selectedValue = select.value;
                const selectedOption = select.options[select.selectedIndex];
                if (selectedOption) {
                    trigger.querySelector('#refresh-dropdown-text').textContent = selectedOption.textContent.trim();
                    const customOption = menu.querySelector(`[data-value="${selectedValue}"]`);
                    if (customOption) {
                        menu.querySelectorAll('.dropdown-option').forEach(opt => opt.classList.remove('selected'));
                        customOption.classList.add('selected');
                    }
                }
            }
        }

        function initializeFilterDropdowns() {
            ['execution-status', 'result-status'].forEach(type => {
                const select = document.getElementById(`filter-${type}`);
                const trigger = document.getElementById(`filter-${type}-trigger`);
                const menu = document.getElementById(`filter-${type}-menu`);
                const textElement = document.getElementById(`filter-${type}-text`);
                
                if (select && trigger && menu && textElement) {
                    const selectedValue = select.value || '';
                    const selectedOption = select.options[select.selectedIndex];
                    if (selectedOption) {
                        textElement.textContent = selectedOption.textContent.trim();
                        const customOption = menu.querySelector(`[data-value="${selectedValue}"]`);
                        if (customOption) {
                            menu.querySelectorAll('.dropdown-option').forEach(opt => opt.classList.remove('selected'));
                            customOption.classList.add('selected');
                        } else {
                            // Select the first option (All Statuses)
                            const firstOption = menu.querySelector('.dropdown-option');
                            if (firstOption) {
                                firstOption.classList.add('selected');
                                textElement.textContent = firstOption.textContent.trim();
                            }
                        }
                    }
                }
            });
        }

        // === SIMPLE DROPDOWN TOGGLE â€” PURE CSS POSITIONING ===
        function toggleDropdown(trigger) {
            const menu = trigger.nextElementSibling;
            if (!menu || !menu.classList.contains('dropdown-menu')) return;

            const isOpen = menu.classList.contains('show');
            
            // Close all dropdowns
            document.querySelectorAll('.dropdown-menu.show').forEach(m => {
                m.classList.remove('show');
                const mTrigger = m.previousElementSibling;
                if (mTrigger) {
                    mTrigger.classList.remove('active');
                    mTrigger.setAttribute('aria-expanded', 'false');
                }
            });
            document.querySelectorAll('.dropdown-trigger.active').forEach(t => t.classList.remove('active'));

            if (isOpen) {
                trigger.classList.remove('active');
                trigger.setAttribute('aria-expanded', 'false');
                return;
            }

            // Open this dropdown
            trigger.classList.add('active');
            trigger.setAttribute('aria-expanded', 'true');
            menu.classList.add('show');

            // Focus first option for keyboard navigation
            const firstOption = menu.querySelector('.dropdown-option');
            if (firstOption) {
                setTimeout(() => firstOption.focus(), 0);
            }
        }
        
        // Keyboard navigation for dropdown triggers
        function handleDropdownKeydown(event, trigger) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                toggleDropdown(trigger);
            } else if (event.key === 'Escape') {
                const menu = trigger.nextElementSibling;
                if (menu && menu.classList.contains('dropdown-menu')) {
                    menu.classList.remove('show');
                    trigger.classList.remove('active');
                    trigger.setAttribute('aria-expanded', 'false');
                }
            }
        }
        
        // Keyboard navigation for dropdown options
        function handleDropdownOptionKeydown(event, value) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                selectRefreshOption(value);
            } else if (event.key === 'Escape') {
                const menu = event.target.closest('.dropdown-menu');
                const trigger = menu ? menu.previousElementSibling : null;
                if (trigger) {
                    menu.classList.remove('show');
                    trigger.classList.remove('active');
                    trigger.setAttribute('aria-expanded', 'false');
                    trigger.focus();
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                const options = Array.from(event.target.parentElement.querySelectorAll('.dropdown-option'));
                const currentIndex = options.indexOf(event.target);
                const nextIndex = (currentIndex + 1) % options.length;
                options[nextIndex].focus();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                const options = Array.from(event.target.parentElement.querySelectorAll('.dropdown-option'));
                const currentIndex = options.indexOf(event.target);
                const prevIndex = (currentIndex - 1 + options.length) % options.length;
                options[prevIndex].focus();
            }
        }

        // Global click-to-dismiss
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                document.querySelectorAll('.dropdown-menu.show').forEach(m => m.classList.remove('show'));
                document.querySelectorAll('.dropdown-trigger.active').forEach(t => t.classList.remove('active'));
            }
        });

        function selectRefreshOption(value) {
            const texts = {0: 'Manual Refresh', 5000: '5s', 10000: '10s', 30000: '30s', 60000: '1m'};
            const select = document.getElementById('auto-refresh-select');
            const trigger = document.getElementById('refresh-dropdown-trigger');
            const menu = document.getElementById('refresh-dropdown-menu');
            const options = menu.querySelectorAll('.dropdown-option');
            
            if (select) select.value = value;
            options.forEach(opt => opt.classList.remove('selected'));
            const selectedOption = Array.from(options).find(opt => opt.dataset.value === value.toString());
            if (selectedOption) {
                selectedOption.classList.add('selected');
                trigger.querySelector('#refresh-dropdown-text').textContent = texts[value] || '10s';
            }
            
            // Save refresh interval to localStorage for persistence across page navigations
            localStorage.setItem('autoRefreshInterval', value.toString());
            
            // Close all dropdowns
            document.querySelectorAll('.dropdown-menu.show').forEach(m => m.classList.remove('show'));
            document.querySelectorAll('.dropdown-trigger.active').forEach(t => t.classList.remove('active'));
            updateAutoRefresh();
        }

        // Auto Refresh Logic
        function updateAutoRefresh() {
            const select = document.getElementById('auto-refresh-select');
            const interval = parseInt(select.value);
            if (refreshInterval) clearInterval(refreshInterval);
            if (countdownInterval) clearInterval(countdownInterval);

            // Save refresh interval to localStorage when changed via select element directly
            if (select && select.value) {
                localStorage.setItem('autoRefreshInterval', select.value);
            }

            if (interval > 0) {
                // Use PollingManager for smart polling
                refreshInterval = pollingManager.start(refreshDatabaseData, interval);
                startCountdown(interval);
            } else {
                document.getElementById('refresh-countdown').textContent = '--';
            }
        }

        function startCountdown(intervalMs) {
            const el = document.getElementById('refresh-countdown');
            let seconds = Math.floor(intervalMs / 1000);
            el.textContent = seconds;
            countdownInterval = pollingManager.start(() => {
                seconds--;
                if (seconds <= 0) seconds = Math.floor(intervalMs / 1000);
                el.textContent = seconds;
            }, 1000);
        }

        // Data Fetching
        async function refreshDatabaseData() {
            // Prevent overlapping refresh requests
            if (isFetching) return;
            isFetching = true;
            
            try {
                await Promise.allSettled([
                    loadDatabaseHealth(),
                    loadDatabaseOperations(),
                    loadDatabaseStatistics(),
                    refreshExecutions(), // Use refresh function instead of load
                    refreshResults()    // Use refresh function instead of load
                ]);
                updateSystemStatus(true);
            } catch (error) {
                updateSystemStatus(false);
            } finally {
                isFetching = false; // Release lock
            }
        }

        function updateSystemStatus(isOnline) {
            const statusEl = document.querySelector('.system-status');
            const text = statusEl.querySelector('span');
            
            if (isOnline) {
                statusEl.classList.remove('status-error');
                text.textContent = 'System Operational';
            } else {
                statusEl.classList.add('status-error');
                text.textContent = 'Connection Issue';
            }
        }

        async function loadDatabaseHealth() {
            try {
                const res = await authenticatedFetch('/api/v1/database/health?_t=' + Date.now());
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                const data = await parseJsonResponse(res);
                renderHealth(data);
            } catch (e) {
                console.error('Failed to load database health:', e);
                renderError('database-health-overview');
            }
        }

        function renderHealth(data) {
            const container = document.getElementById('database-health-overview');
            const connStatus = data.connectionStatus || 'UNKNOWN';
            const statusColor = connStatus === 'HEALTHY' ? 'text-success' : 'text-danger';
            
            const tableStats = data.tableStatistics || [];
            // Use optional chaining with nullish coalescing for safe deep object access
            const cacheHit = data.performanceMetrics?.cacheHitRatio ?? 0;
            const activeConns = data.connectionPoolStatus?.activeConnections ?? 0;

            container.innerHTML = `
                <div class="metric-item">
                    <div class="metric-value ${statusColor}">${connStatus}</div>
                    <div class="metric-label">Status</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value">${tableStats.length}</div>
                    <div class="metric-label">Tables</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value text-success">${cacheHit}%</div>
                    <div class="metric-label">Cache Hit</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value">${activeConns}</div>
                    <div class="metric-label">Active Conn</div>
                </div>
            `;
            
            if (tableStats.length > 0) {
                updateChart(tableStats);
            }
        }

        async function loadDatabaseOperations() {
            try {
                const res = await authenticatedFetch('/api/v1/database/operations?_t=' + Date.now());
                if (!res.ok) throw new Error('Failed');
                const data = await parseJsonResponse(res);
                
                document.getElementById('real-time-operations').innerHTML = `
                    <div class="metric-item">
                        <div class="metric-value text-info">${(data.totalInserts ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Inserts</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value text-primary">${(data.totalUpdates ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Updates</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value text-success">${(data.totalSelects ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Selects</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value text-warning">${(data.totalDeletes ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Deletes</div>
                    </div>
                `;
            } catch (e) { renderError('real-time-operations'); }
        }

        async function loadDatabaseStatistics() {
            try {
                const res = await authenticatedFetch('/api/v1/database/statistics?_t=' + Date.now());
                if (!res.ok) throw new Error('Failed');
                const data = await parseJsonResponse(res);
                
                document.getElementById('database-statistics').innerHTML = `
                    <div class="metric-item">
                        <div class="metric-value">${(data.totalExecutions ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Executions</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">${(data.totalResults ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Results</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">${(data.totalSteps ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Steps</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value">${(data.totalAttachments ?? 0).toLocaleString()}</div>
                        <div class="metric-label">Attachments</div>
                    </div>
                `;
            } catch (e) { renderError('database-statistics'); }
        }

        function updateChart(tableStats) {
            const canvas = document.getElementById('tableStatisticsChart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            // Check for valid canvas dimensions to prevent zero-width gradient error
            const width = canvas.width || canvas.offsetWidth || 200;
            const height = canvas.height || canvas.offsetHeight || 200;
            
            // Define segment colors for spider labels (matching the gradient colors)
            const segmentColorsForLabels = [
                '#ec4899',  // Pink/Magenta
                '#3b82f6',  // Blue
                '#f43f5e',  // Red/Pink
                '#8b5cf6',  // Purple
                '#06b6d4',  // Cyan
                '#f59e0b'   // Orange/Yellow
            ];
            
            // Spider-style label plugin for callout labels (declared here so it's accessible in both update and init paths)
            // IMPORTANT: This plugin must be registered AFTER radialTubes3DPlugin so its afterDraw runs last
            const createSpiderLabelPlugin = () => ({
                id: 'spiderLabels',
                afterDraw: (chart) => {
                    const ctx = chart.ctx;
                    const chartArea = chart.chartArea;
                    
                    // Ensure chart area is valid and has proper dimensions
                    if (!chartArea || 
                        chartArea.left === undefined || 
                        chartArea.right === undefined || 
                        chartArea.top === undefined || 
                        chartArea.bottom === undefined ||
                        chartArea.right <= chartArea.left ||
                        chartArea.bottom <= chartArea.top) {
                        return;
                    }
                    
                    const centerX = (chartArea.left + chartArea.right) / 2;
                    const centerY = (chartArea.top + chartArea.bottom) / 2;
                    const radius = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top) / 2;
                    
                    // Ensure radius is valid
                    if (radius <= 0 || !isFinite(radius)) {
                        return;
                    }
                    
                    const outerRadius = radius;
                    const innerRadius = radius * 0.80; // Increased from 0.75 to 0.80 for thinner ring
                    const labelRadius = outerRadius + 35; // Distance from chart edge to label
                    
                    const chartData = chart.data.datasets[0].data;
                    const labels = chart.data.labels;
                    
                    if (!chartData || !labels || chartData.length === 0 || labels.length === 0) {
                        return;
                    }
                    
                    const total = chartData.reduce((a, b) => a + b, 0);
                    
                    if (total === 0 || !isFinite(total)) {
                        return;
                    }
                    
                    const textColor = '#ffffff';
                    
                    let currentAngle = -Math.PI / 2; // Start at top
                    const gapAngle = (Math.PI * 2) * 0.01;
                    
                    chartData.forEach((value, index) => {
                        if (value === 0 || !labels[index]) {
                            // Skip zero segments but still advance angle
                            const segmentAngle = (value / total) * (Math.PI * 2 - gapAngle * chartData.filter(d => d > 0).length);
                            currentAngle += segmentAngle + gapAngle;
                            return;
                        }
                        
                        const segmentAngle = (value / total) * (Math.PI * 2 - gapAngle * chartData.filter(d => d > 0).length);
                        const midAngle = currentAngle + segmentAngle / 2;
                        
                        // Get segment color - match the pie chart segment color
                        let segmentColor = segmentColorsForLabels[index % segmentColorsForLabels.length];
                        if (chart.data.datasets[0].backgroundColor && chart.data.datasets[0].backgroundColor[index]) {
                            if (typeof chart.data.datasets[0].backgroundColor[index] === 'string') {
                                segmentColor = chart.data.datasets[0].backgroundColor[index];
                            } else {
                                // For gradients, use the matching segment color from our array
                                segmentColor = segmentColorsForLabels[index % segmentColorsForLabels.length];
                            }
                        }
                        
                        // Intelligently choose starting angle to avoid label truncation
                        // For segments on left/right sides, prefer angles closer to top/bottom for better label positioning
                        const segmentStart = currentAngle;
                        const segmentEnd = currentAngle + segmentAngle;
                        
                        // Calculate candidate angles within the segment
                        // Try angles at 25%, 50% (mid), and 75% of the segment
                        const candidateAngles = [
                            segmentStart + segmentAngle * 0.25,
                            midAngle,
                            segmentStart + segmentAngle * 0.75
                        ];
                        
                        // Choose the angle that's most vertical (furthest from horizontal edges)
                        // This gives more horizontal space for labels on left/right sides
                        let startAngle = midAngle;
                        let maxVerticalDistance = 0;
                        
                        candidateAngles.forEach(angle => {
                            // Calculate how vertical this angle is (distance from horizontal center)
                            const verticalDistance = Math.abs(Math.sin(angle));
                            // For left/right segments, prefer more vertical angles
                            if (verticalDistance > maxVerticalDistance) {
                                maxVerticalDistance = verticalDistance;
                                startAngle = angle;
                            }
                        });
                        
                        // Recalculate side and direction based on chosen angle
                        const finalIsRight = Math.cos(startAngle) >= 0;
                        const finalIsTop = Math.sin(startAngle) < 0;
                        
                        // Start point on pie edge using the intelligently chosen angle
                        const x0 = centerX + Math.cos(startAngle) * (outerRadius + 2);
                        const y0 = centerY + Math.sin(startAngle) * (outerRadius + 2);
                        
                        // Calculate responsive label offsets based on chart radius
                        const offsets = calculateSpiderLabelOffsets(outerRadius);
                        const slantLength = offsets.slantLength;
                        const verticalOffset = finalIsTop ? -offsets.verticalOffset : offsets.verticalOffset;
                        const x1 = x0 + (finalIsRight ? offsets.horizontalLength : -offsets.horizontalLength);
                        const y1 = y0 + verticalOffset;
                        
                        // HORIZONTAL second leg
                        const horizontalLength = offsets.horizontalLength;
                        const x2 = x1 + (finalIsRight ? horizontalLength : -horizontalLength);
                        const y2 = y1; // Same Y = horizontal
                        
                        // Text anchor and offset
                        const textAnchor = finalIsRight ? 'left' : 'right';
                        const textOffsetX = (finalIsRight ? 1 : -1) * 10;
                        
                        // Draw thick L-shaped line with glow
                        ctx.save();
                        ctx.strokeStyle = segmentColor;
                        ctx.lineWidth = 2.5;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.shadowColor = segmentColor;
                        ctx.shadowBlur = 12;
                        
                        ctx.beginPath();
                        ctx.moveTo(x0, y0);
                        ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.restore();
                        
                        // Dot at pie edge
                        ctx.save();
                        ctx.fillStyle = segmentColor;
                        ctx.shadowColor = segmentColor;
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(x0, y0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        
                        // Dot at elbow
                        ctx.save();
                        ctx.fillStyle = segmentColor;
                        ctx.shadowColor = segmentColor;
                        ctx.shadowBlur = 6;
                        ctx.beginPath();
                        ctx.arc(x1, y1, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        
                        // Bold label text - two lines
                        const percentage = ((value / total) * 100).toFixed(0);
                        const labelName = labels[index] || '';
                        const textX = x2 + textOffsetX;
                        
                        ctx.save();
                        ctx.fillStyle = textColor;
                        ctx.textAlign = textAnchor;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                        ctx.shadowBlur = 6;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        
                        // Draw label name (top line)
                        ctx.font = '900 14px Inter, sans-serif';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText(labelName, textX, y2 - 2);
                        
                        // Draw percentage (bottom line)
                        ctx.font = '700 13px Inter, sans-serif';
                        ctx.textBaseline = 'top';
                        ctx.fillText(`${percentage}%`, textX, y2 + 2);
                        
                        ctx.restore();
                        
                        currentAngle += segmentAngle + gapAngle;
                    });
                }
            });
            
            // Update chart data instead of destroying/recreating to prevent flickering
            if (tableStatisticsChart) {
            const labels = tableStats.map(t => t.tableName.replace('test_', ''));
            const data = tableStats.map(t => t.recordCount || 0);
            const totalRecords = data.reduce((a, b) => a + b, 0);
            
            // Update center total
            document.getElementById('db-distribution-total').textContent = totalRecords.toLocaleString();

                // Ensure spider label plugin is registered for updates
                const existingPlugin = tableStatisticsChart.config.plugins.find(p => p.id === 'spiderLabels');
                if (!existingPlugin) {
                    tableStatisticsChart.config.plugins.push(createSpiderLabelPlugin());
                }
                
                // Ensure layout padding is set for spider labels
                if (!tableStatisticsChart.options.layout) {
                    tableStatisticsChart.options.layout = {};
                }
                if (!tableStatisticsChart.options.layout.padding) {
                    tableStatisticsChart.options.layout.padding = { top: 60, bottom: 60, left: 120, right: 120 }; // Increased padding to prevent label truncation
                }
                
                // Handle zero data case (reuse totalRecords from above)
                if (totalRecords === 0) {
                    const placeholderGradient = ctx.createLinearGradient(0, 0, width, height);
                    placeholderGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                    placeholderGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                    tableStatisticsChart.data.labels = []; // Clear labels to prevent showing 100% with old label
                    tableStatisticsChart.data.datasets[0].data = [1];
                    tableStatisticsChart.data.datasets[0].backgroundColor = [placeholderGradient];
                    tableStatisticsChart.options.plugins.tooltip.enabled = false;
                    tableStatisticsChart.update('default');
                    return;
                }
                
                // Recalculate gradients on resize
                const chartArea = tableStatisticsChart.chartArea;
                if (chartArea && width > 0 && height > 0) {
            const gradientColors = [
                { start: '#ec4899', end: '#f472b6', glow: 'rgba(236, 72, 153, 0.4)' },
                { start: '#3b82f6', end: '#60a5fa', glow: 'rgba(59, 130, 246, 0.4)' },
                { start: '#f43f5e', end: '#fb7185', glow: 'rgba(244, 63, 94, 0.4)' },
                { start: '#8b5cf6', end: '#a78bfa', glow: 'rgba(139, 92, 246, 0.4)' },
                { start: '#06b6d4', end: '#22d3ee', glow: 'rgba(6, 182, 212, 0.4)' },
                { start: '#f59e0b', end: '#fbbf24', glow: 'rgba(245, 158, 11, 0.4)' }
            ];

            const backgroundColors = data.map((value, index) => {
                        const gradient = ctx.createLinearGradient(0, 0, width, height);
                const colors = gradientColors[index % gradientColors.length];
                gradient.addColorStop(0, colors.start);
                gradient.addColorStop(1, colors.end);
                return gradient;
            });

                    tableStatisticsChart.data.labels = labels;
                    tableStatisticsChart.data.datasets[0].data = data;
                    tableStatisticsChart.data.datasets[0].backgroundColor = backgroundColors;
                    tableStatisticsChart.options.plugins.tooltip.enabled = false;
                } else {
                    tableStatisticsChart.data.labels = labels;
                    tableStatisticsChart.data.datasets[0].data = data;
                }
                
                // Force update to ensure plugins (including spider labels) are redrawn
                // Use 'default' mode to ensure all plugins execute (including afterDraw hooks)
                tableStatisticsChart.update('default');
                return;
            }
            
            // Only create chart if it doesn't exist

            const labels = tableStats.map(t => t.tableName.replace('test_', ''));
            const data = tableStats.map(t => t.recordCount || 0);
            const totalRecords = data.reduce((a, b) => a + b, 0);
            
            // Update center total
            document.getElementById('db-distribution-total').textContent = totalRecords.toLocaleString();

            const gradientColors = [
                { start: '#ec4899', end: '#f472b6', glow: 'rgba(236, 72, 153, 0.4)' },
                { start: '#3b82f6', end: '#60a5fa', glow: 'rgba(59, 130, 246, 0.4)' },
                { start: '#f43f5e', end: '#fb7185', glow: 'rgba(244, 63, 94, 0.4)' },
                { start: '#8b5cf6', end: '#a78bfa', glow: 'rgba(139, 92, 246, 0.4)' },
                { start: '#06b6d4', end: '#22d3ee', glow: 'rgba(6, 182, 212, 0.4)' },
                { start: '#f59e0b', end: '#fbbf24', glow: 'rgba(245, 158, 11, 0.4)' }
            ];

            // 3D Radial Tubes Plugin with Depth Effects - MUST be declared before use
            const radialTubes3DPlugin = {
                id: 'radialTubes3D',
                afterLayout: (chart) => {
                    // Recalculate gradients after layout changes (including resize)
                    const chartCanvas = chart.canvas;
                    const chartCtx = chartCanvas.getContext('2d');
                    const chartWidth = chartCanvas.width || chartCanvas.offsetWidth || 200;
                    const chartHeight = chartCanvas.height || chartCanvas.offsetHeight || 200;
                    if (chartWidth > 0 && chartHeight > 0) {
                        const gradientColors = [
                            { start: '#ec4899', end: '#f472b6', glow: 'rgba(236, 72, 153, 0.4)' },
                            { start: '#3b82f6', end: '#60a5fa', glow: 'rgba(59, 130, 246, 0.4)' },
                            { start: '#f43f5e', end: '#fb7185', glow: 'rgba(244, 63, 94, 0.4)' },
                            { start: '#8b5cf6', end: '#a78bfa', glow: 'rgba(139, 92, 246, 0.4)' },
                            { start: '#06b6d4', end: '#22d3ee', glow: 'rgba(6, 182, 212, 0.4)' },
                            { start: '#f59e0b', end: '#fbbf24', glow: 'rgba(245, 158, 11, 0.4)' }
                        ];
                        
                        const backgroundColors = chart.data.datasets[0].data.map((value, index) => {
                            const gradient = chartCtx.createLinearGradient(0, 0, chartWidth, chartHeight);
                            const colors = gradientColors[index % gradientColors.length];
                            gradient.addColorStop(0, colors.start);
                            gradient.addColorStop(1, colors.end);
                            return gradient;
                        });
                        
                        chart.data.datasets[0].backgroundColor = backgroundColors;
                    }
                },
                beforeDraw: (chart) => {
                    const chartCtx = chart.ctx;
                    const chartArea = chart.chartArea;
                    const centerX = (chartArea.left + chartArea.right) / 2;
                    const centerY = (chartArea.top + chartArea.bottom) / 2;
                    const radius = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top) / 2;
                    
                    // Draw inner shadow for depth
                    chartCtx.save();
                    const innerRadius = radius * 0.80; // Increased from 0.75 to 0.80 for thinner ring
                    const shadowGradient = chartCtx.createRadialGradient(centerX, centerY, innerRadius * 0.5, centerX, centerY, innerRadius);
                    shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                    shadowGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.2)');
                    shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    chartCtx.fillStyle = shadowGradient;
                    chartCtx.beginPath();
                    chartCtx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                    chartCtx.fill();
                    chartCtx.restore();
                },
                afterDraw: (chart) => {
                    const chartCtx = chart.ctx;
                    const chartArea = chart.chartArea;
                    const centerX = (chartArea.left + chartArea.right) / 2;
                    const centerY = (chartArea.top + chartArea.bottom) / 2;
                    const radius = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top) / 2;
                    const outerRadius = radius;
                    const innerRadius = radius * 0.80; // Increased from 0.75 to 0.80 for thinner ring
                    const chartData = chart.data.datasets[0].data;
                    const total = chartData.reduce((a, b) => a + b, 0);
                    if (total === 0) return; // Skip drawing if no data
                    const tubeThickness = (outerRadius - innerRadius) / Math.max(chartData.length, 1);
                    
                    let currentAngle = -Math.PI / 2;
                    const gapAngle = (Math.PI * 2) * 0.01;
                    
                    // Optimization: Reduce shadow blur during hover to improve performance
                    const isHovering = chart.tooltip && chart.tooltip._active && chart.tooltip._active.length > 0;
                    const shadowBlur = isHovering ? 4 : 12; // Reduce blur on hover
                    const glowBlur = isHovering ? 8 : 20; // Reduce glow blur on hover
                    
                    chartData.forEach((value, index) => {
                        if (value === 0) return;
                        
                        const segmentAngle = (value / total) * (Math.PI * 2 - gapAngle * chartData.filter(d => d > 0).length);
                        const colors = gradientColors[index % gradientColors.length];
                        const tubeRadius = innerRadius + (tubeThickness * (index + 0.5));
                        
                        // Draw shadow arc behind segment for depth (offset)
                        chartCtx.save();
                        chartCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        chartCtx.lineWidth = tubeThickness * 0.9;
                        chartCtx.lineCap = 'round';
                        chartCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                        chartCtx.shadowBlur = shadowBlur; // Use optimized blur
                        chartCtx.shadowOffsetX = 3;
                        chartCtx.shadowOffsetY = 4;
                        chartCtx.beginPath();
                        chartCtx.arc(centerX + 2, centerY + 3, tubeRadius, currentAngle, currentAngle + segmentAngle);
                        chartCtx.stroke();
                        chartCtx.restore();
                        
                        // Draw 3D tube effect - outer glow
                        chartCtx.save();
                        chartCtx.strokeStyle = colors.glow;
                        chartCtx.lineWidth = tubeThickness * 0.8;
                        chartCtx.lineCap = 'round';
                        chartCtx.shadowColor = colors.glow;
                        chartCtx.shadowBlur = glowBlur; // Use optimized blur
                        chartCtx.shadowOffsetX = 0;
                        chartCtx.shadowOffsetY = 0;
                        chartCtx.beginPath();
                        chartCtx.arc(centerX, centerY, tubeRadius, currentAngle, currentAngle + segmentAngle);
                        chartCtx.stroke();
                        
                        // Draw inner highlight for 3D effect
                        chartCtx.strokeStyle = colors.start;
                        chartCtx.lineWidth = tubeThickness * 0.3;
                        chartCtx.shadowBlur = 0;
                        chartCtx.beginPath();
                        chartCtx.arc(centerX, centerY, tubeRadius - tubeThickness * 0.2, currentAngle, currentAngle + segmentAngle);
                        chartCtx.stroke();
                        
                        // Draw outer highlight
                        chartCtx.strokeStyle = colors.end;
                        chartCtx.lineWidth = tubeThickness * 0.2;
                        chartCtx.beginPath();
                        chartCtx.arc(centerX, centerY, tubeRadius + tubeThickness * 0.2, currentAngle, currentAngle + segmentAngle);
                        chartCtx.stroke();
                        
                        // Draw inner highlight for depth
                        chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        chartCtx.lineWidth = tubeThickness * 0.15;
                        chartCtx.beginPath();
                        chartCtx.arc(centerX, centerY, innerRadius + 4, currentAngle, currentAngle + segmentAngle);
                        chartCtx.stroke();
                        
                        chartCtx.restore();
                        currentAngle += segmentAngle + gapAngle;
                    });
                    
                    // Subtle inner circle border
                    chartCtx.save();
                    chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                    chartCtx.lineWidth = 1;
                    chartCtx.beginPath();
                    chartCtx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                    chartCtx.stroke();
                    chartCtx.restore();
                }
            };

            // Handle zero data case - show placeholder ring to prevent invisible chart (reuse totalRecords from above)
            if (totalRecords === 0) {
                const placeholderGradient = ctx.createLinearGradient(0, 0, width, height);
                placeholderGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                placeholderGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                
                tableStatisticsChart = new Chart(ctx, {
                    type: 'doughnut',
                    plugins: [radialTubes3DPlugin, createSpiderLabelPlugin()],
                    data: {
                        labels: [], // Empty labels to prevent showing 100% with placeholder data
                        datasets: [{
                            data: [1],
                            backgroundColor: [placeholderGradient],
                            borderWidth: 0,
                            hoverOffset: 0,
                            spacing: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '80%', // Increased from 78% to 80% for thinner ring
                        rotation: -90,
                        circumference: 360,
                        layout: {
                            padding: {
                                top: 60,
                                bottom: 60,
                                left: 120,
                                right: 120 // Increased padding to prevent label truncation
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    }
                });
                return;
            }
            
            const backgroundColors = data.map((value, index) => {
                const gradient = ctx.createLinearGradient(0, 0, width, height);
                const colors = gradientColors[index % gradientColors.length];
                gradient.addColorStop(0, colors.start);
                gradient.addColorStop(1, colors.end);
                return gradient;
            });

            // Use the radialTubes3DPlugin and spiderLabelPlugin declared above (before zero data check)
            // IMPORTANT: Register spiderLabelPlugin LAST so its afterDraw hook runs after radialTubes3DPlugin's afterDraw
            tableStatisticsChart = new Chart(ctx, {
                type: 'doughnut',
                plugins: [radialTubes3DPlugin, createSpiderLabelPlugin()],
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderWidth: 0,
                        hoverOffset: 4,
                        spacing: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '80%', // Increased from 78% to 80% for thinner ring
                    rotation: -90,
                    circumference: 360,
                    layout: {
                        padding: {
                            top: 60,
                            bottom: 60,
                            left: 120,
                            right: 120 // Increased padding to prevent label truncation
                        }
                    },
                    animation: isFirstChartLoad ? {
                        animateRotate: true,
                        animateScale: false,
                        duration: 1500,
                        easing: 'easeOutCubic'
                    } : false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: false
                        }
                    },
                    onResize: (chart) => {
                        // Recalculate gradients on resize
                        const canvas = chart.canvas;
                        const ctx = canvas.getContext('2d');
                        const width = canvas.width || canvas.offsetWidth || 200;
                        const height = canvas.height || canvas.offsetHeight || 200;
                        if (width > 0 && height > 0) {
                            const gradientColors = [
                                { start: '#ec4899', end: '#f472b6', glow: 'rgba(236, 72, 153, 0.4)' },
                                { start: '#3b82f6', end: '#60a5fa', glow: 'rgba(59, 130, 246, 0.4)' },
                                { start: '#f43f5e', end: '#fb7185', glow: 'rgba(244, 63, 94, 0.4)' },
                                { start: '#8b5cf6', end: '#a78bfa', glow: 'rgba(139, 92, 246, 0.4)' },
                                { start: '#06b6d4', end: '#22d3ee', glow: 'rgba(6, 182, 212, 0.4)' },
                                { start: '#f59e0b', end: '#fbbf24', glow: 'rgba(245, 158, 11, 0.4)' }
                            ];
                            
                            const backgroundColors = chart.data.datasets[0].data.map((value, index) => {
                                const gradient = ctx.createLinearGradient(0, 0, width, height);
                                const colors = gradientColors[index % gradientColors.length];
                                gradient.addColorStop(0, colors.start);
                                gradient.addColorStop(1, colors.end);
                                return gradient;
                            });
                            
                            chart.data.datasets[0].backgroundColor = backgroundColors;
                        }
                    }
                }
            });
            
            // Disable animation for subsequent updates
            if (isFirstChartLoad) {
                isFirstChartLoad = false;
            }
        }

        async function loadExecutions(reset = true) {
            if (isLoadingExecutions) return; // Prevent concurrent loads
            isLoadingExecutions = true;
            const timestamp = Date.now();
            loadExecutionsTimestamp = timestamp;
            
            try {
                const tbody = document.querySelector('#executions-table tbody');
                
                // Reset pagination and data if this is a fresh load
                if (reset) {
                    executionsPage = 0;
                    allExecutionsData = [];
                    executionsHasMore = true;
                    if (tbody) {
                        tbody.innerHTML = '';
                    }
                }
                
                // Remove any loading rows that might exist
                if (tbody) {
                    const loadingRow = tbody.querySelector('tr td.table-loading');
                    if (loadingRow) {
                        loadingRow.closest('tr').remove();
                    }
                }
                
                // Show loading indicator
                if (tbody && reset) {
                    const loadingRow = document.createElement('tr');
                    loadingRow.innerHTML = '<td colspan="9" class="table-loading">Loading executions...</td>';
                    tbody.appendChild(loadingRow);
                }
                
                // Fetch page from API
                const res = await authenticatedFetch(`/api/v1/database/browse/executions?page=${executionsPage}&size=${pageSize}&sortBy=startTime&sortDir=desc&_t=${timestamp}`);
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                
                // Only update if this is still the latest load
                if (timestamp === loadExecutionsTimestamp) {
                    const data = await parseJsonResponse(res);
                    executionsTotalPages = data.totalPages || 0;
                    executionsHasMore = executionsPage < executionsTotalPages - 1;
                    
                    // Append or replace data based on reset flag
                    if (reset) {
                        allExecutionsData = data.content || [];
                    } else {
                        allExecutionsData = [...allExecutionsData, ...(data.content || [])];
                    }

                    // Ensure loading row is removed before rendering
                    const tbody = document.querySelector('#executions-table tbody');
                    if (tbody) {
                        const loadingRow = tbody.querySelector('tr td.table-loading');
                        if (loadingRow) {
                            loadingRow.closest('tr').remove();
                        }
                    }

                    // Render the table with all loaded data (append if loading more)
                    renderExecutionsTable({ content: allExecutionsData, totalPages: executionsTotalPages }, !reset);
                }
            } catch (e) {
                console.error('Failed to load executions:', e);
                // Only show error if this is still the latest load
                if (timestamp === loadExecutionsTimestamp) {
                    const tbody = document.querySelector('#executions-table tbody');
                    if (tbody) {
                        const errorRow = document.createElement('tr');
                        errorRow.innerHTML = '<td colspan="9" class="table-error">Failed to load data: ' + (e.message || 'Unknown error') + '</td>';
                        requestAnimationFrame(() => {
                            tbody.innerHTML = '';
                            tbody.appendChild(errorRow);
                        });
                    }
                }
            } finally {
                if (timestamp === loadExecutionsTimestamp) {
                    isLoadingExecutions = false;
                }
            }
        }

        async function loadMoreExecutions() {
            if (!executionsHasMore || isLoadingExecutions) return;
            executionsPage++;
            await loadExecutions(false);
        }

        // Refresh executions without resetting scroll or clearing table
        async function refreshExecutions() {
            if (isLoadingExecutions) return;
            
            const wrapper = document.querySelector('#executions-table')?.closest('.table-wrapper');
            const scrollTop = wrapper ? wrapper.scrollTop : 0;
            
            // Fetch only first page to update existing data
            const originalPage = executionsPage;
            executionsPage = 0;
            
            try {
                const timestamp = Date.now();
                const res = await authenticatedFetch(`/api/v1/database/browse/executions?page=0&size=${pageSize}&sortBy=startTime&sortDir=desc&_t=${timestamp}`);
                if (!res.ok) return;
                
                const data = await parseJsonResponse(res);
                const newData = data.content || [];
                
                // Update existing rows in place instead of re-rendering
                updateExecutionsTableInPlace(newData);
                
                // Restore scroll position
                if (wrapper) {
                    requestAnimationFrame(() => {
                        wrapper.scrollTop = scrollTop;
                    });
                }
            } catch (e) {
                console.error('Failed to refresh executions:', e);
            } finally {
                executionsPage = originalPage;
            }
        }

        // Update executions table in place without clearing
        function updateExecutionsTableInPlace(newData) {
            const tbody = document.querySelector('#executions-table tbody');
            if (!tbody) return;
            
            // Create a map of new data by ID
            const newDataMap = new Map();
            newData.forEach(exec => {
                newDataMap.set(exec.id, exec);
            });
            
            // Get existing rows
            const existingRows = Array.from(tbody.querySelectorAll('tr[data-execution-id]'));
            const existingIds = new Set();
            
            // Update existing rows in place
            existingRows.forEach(row => {
                const id = parseInt(row.dataset.executionId);
                if (!id) return;
                
                existingIds.add(id);
                const newExec = newDataMap.get(id);
                
                if (newExec) {
                    // Update row in place
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 9) {
                        // Update status (cell 3)
                        const statusCell = cells[3];
                        const newStatusBadge = getStatusBadge(newExec.status);
                        if (statusCell.innerHTML !== newStatusBadge) {
                            statusCell.innerHTML = newStatusBadge;
                        }
                        
                        // Update duration (cell 5)
                        const durationCell = cells[5];
                        const newDuration = calculateDuration(newExec.startTime, newExec.endTime, newExec.status);
                        if (durationCell.textContent !== newDuration) {
                            durationCell.textContent = newDuration;
                        }
                        
                        // Update result count (cell 7)
                        const resultCountCell = cells[7];
                        if (resultCountCell.textContent !== String(newExec.resultCount || 0)) {
                            resultCountCell.textContent = newExec.resultCount || 0;
                        }
                    }
                }
            });
            
            // Add new rows that don't exist yet (only if they're in the first page)
            // We only add new rows at the top if they're newer than existing ones
            const firstNewId = newData.length > 0 ? newData[0].id : null;
            const lastExistingId = existingRows.length > 0 ? 
                Math.max(...Array.from(existingRows).map(r => parseInt(r.dataset.executionId) || 0)) : 0;
            
            // Only add new rows if they're newer (higher ID) than existing ones
            if (firstNewId && firstNewId > lastExistingId) {
                const fragment = document.createDocumentFragment();
                newData.forEach(exec => {
                    if (!existingIds.has(exec.id)) {
                        const row = document.createElement('tr');
                        row.dataset.executionId = exec.id;
                        row.innerHTML = `
                            <td><span class="metric-label">#${exec.id}</span></td>
                            <td><code class="table-cell-code">${escapeHtml(exec.executionId || '')}</code></td>
                            <td class="table-cell-name">${escapeHtml(exec.suiteName || '-')}</td>
                            <td>${getStatusBadge(exec.status)}</td>
                            <td>${escapeHtml(exec.environment || '-')}</td>
                            <td>${calculateDuration(exec.startTime, exec.endTime, exec.status)}</td>
                            <td class="table-cell-time">${formatTimeWithTimezone(exec.startTime)}</td>
                            <td>${exec.resultCount || 0}</td>
                            <td class="table-cell-actions">
                                <button class="action-btn btn-danger btn-small" onclick="deleteExecution(${exec.id})">Delete</button>
                            </td>
                        `;
                        fragment.appendChild(row);
                    }
                });
                
                // Insert new rows at the top
                if (fragment.children.length > 0) {
                    const firstRow = tbody.querySelector('tr');
                    if (firstRow) {
                        tbody.insertBefore(fragment, firstRow);
                    } else {
                        tbody.appendChild(fragment);
                    }
                }
            }
            
            // Update allExecutionsData with new data (merge, keeping existing data)
            const existingDataMap = new Map();
            allExecutionsData.forEach(exec => existingDataMap.set(exec.id, exec));
            
            // Update existing entries and add new ones
            newData.forEach(exec => {
                existingDataMap.set(exec.id, exec);
            });
            
            // Convert back to array, maintaining order (newest first)
            allExecutionsData = Array.from(existingDataMap.values())
                .sort((a, b) => (b.id || 0) - (a.id || 0));
        }

        function selectFilterOption(type, value) {
            const texts = {
                'execution-status': { '': 'All Statuses', 'PASSED': 'Passed', 'FAILED': 'Failed', 'RUNNING': 'Running' },
                'result-status': { '': 'All Statuses', 'PASSED': 'Passed', 'FAILED': 'Failed' }
            };
            const select = document.getElementById(`filter-${type}`);
            const trigger = document.getElementById(`filter-${type}-trigger`);
            const menu = document.getElementById(`filter-${type}-menu`);
            const textElement = document.getElementById(`filter-${type}-text`);
            const options = menu ? menu.querySelectorAll('.dropdown-option') : [];
            
            if (select) {
                select.value = value || '';
            }
            
            options.forEach(opt => opt.classList.remove('selected'));
            const selectedOption = Array.from(options).find(opt => opt.dataset.value === (value || ''));
            if (selectedOption) {
                selectedOption.classList.add('selected');
                const text = selectedOption.textContent.trim();
                if (textElement) {
                    textElement.textContent = text;
                }
            }
            
            // Apply filters & auto-close
            if (type === 'execution-status') {
                applyExecutionFilters();
            } else if (type === 'result-status') {
                applyResultFilters();
            }
            
            // Close all dropdowns
            document.querySelectorAll('.dropdown-menu.show').forEach(m => m.classList.remove('show'));
            document.querySelectorAll('.dropdown-trigger.active').forEach(t => t.classList.remove('active'));
        }

        function applyExecutionFilters() {
            // Trim inputs to handle copy-paste with accidental spaces
            const idFilter = document.getElementById('filter-execution-id').value.trim().toLowerCase();
            const suiteFilter = document.getElementById('filter-suite-name').value.trim().toLowerCase();
            const statusFilter = document.getElementById('filter-execution-status').value;

            // Apply client-side filtering on loaded data
            // Note: This filters only the data already loaded. For full database search,
            // consider implementing server-side filtering in the API.
            const filtered = allExecutionsData.filter(exec => {
                return (!idFilter || (exec.executionId || '').toLowerCase().includes(idFilter)) &&
                       (!suiteFilter || (exec.suiteName || '').toLowerCase().includes(suiteFilter)) &&
                       (!statusFilter || exec.status === statusFilter);
            });

            renderExecutionsTable({ content: filtered, totalPages: 1 });
        }

        function renderExecutionsTable(data, append = false) {
            const tbody = document.querySelector('#executions-table tbody');
            if (!tbody) return;
            
            const wrapper = tbody.closest('.table-wrapper');
            const scrollTop = wrapper ? wrapper.scrollTop : 0;
            
            // Remove any loading rows
            const loadingRow = tbody.querySelector('tr td.table-loading');
            if (loadingRow) {
                loadingRow.closest('tr').remove();
            }
            
            totalPages = data.totalPages;
            
            // Handle empty state
            if (!data.content.length && !append) {
                tbody.innerHTML = '';
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="9" class="table-empty">No executions found</td>';
                tbody.appendChild(row);
                const paginationEl = document.getElementById('executions-pagination');
                if (paginationEl) paginationEl.innerHTML = '';
                return;
            }
            
            // Get existing row IDs to avoid duplicates when appending
            const existingIds = new Set();
            if (append) {
                Array.from(tbody.querySelectorAll('tr[data-execution-id]')).forEach(row => {
                    const id = row.dataset.executionId;
                    if (id) existingIds.add(id);
                });
            } else {
                tbody.innerHTML = '';
            }
            
            // Render rows
            data.content.forEach((exec) => {
                // Skip if already rendered (when appending)
                if (append && existingIds.has(String(exec.id))) {
                    return;
                }
                
                const row = document.createElement('tr');
                row.dataset.executionId = exec.id;
                row.innerHTML = `
                    <td><span class="metric-label">#${exec.id}</span></td>
                    <td><code class="table-cell-code">${escapeHtml(exec.executionId || '')}</code></td>
                    <td class="table-cell-name">${escapeHtml(exec.suiteName || '-')}</td>
                    <td>${getStatusBadge(exec.status)}</td>
                    <td>${escapeHtml(exec.environment || '-')}</td>
                    <td>${calculateDuration(exec.startTime, exec.endTime, exec.status)}</td>
                    <td class="table-cell-time">${formatTimeWithTimezone(exec.startTime)}</td>
                    <td>${exec.resultCount || 0}</td>
                    <td class="table-cell-actions">
                        <button class="action-btn btn-danger btn-small" onclick="deleteExecution(${exec.id})">Delete</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
            
            // Hide pagination (using infinite scroll instead)
            const paginationEl = document.getElementById('executions-pagination');
            if (paginationEl) paginationEl.innerHTML = '';
            
            // Restore scroll position if we cleared the table
            if (!append && wrapper && scrollTop > 0) {
                requestAnimationFrame(() => {
                    wrapper.scrollTop = scrollTop;
                });
            }
        }

        async function loadResults(reset = true) {
            if (isLoadingResults) return; // Prevent concurrent loads
            isLoadingResults = true;
            const timestamp = Date.now();
            loadResultsTimestamp = timestamp;

            try {
                const tbody = document.querySelector('#results-table tbody');
                if (!tbody) {
                    console.error('Results table tbody not found');
                    return;
                }

                // Reset pagination and data if this is a fresh load
                if (reset) {
                    resultsPage = 0;
                    allResultsData = [];
                    resultsHasMore = true;
                    tbody.innerHTML = '';
                }

                // Remove any loading rows that might exist
                const loadingRow = tbody.querySelector('tr td.table-loading');
                if (loadingRow) {
                    loadingRow.closest('tr').remove();
                }

                // Show loading indicator
                if (reset) {
                    const loadingRow = document.createElement('tr');
                    loadingRow.innerHTML = '<td colspan="8" class="table-loading">Loading results...</td>';
                    tbody.appendChild(loadingRow);
                }

                // Fetch page from API
                const res = await authenticatedFetch(`/api/v1/database/browse/results?page=${resultsPage}&size=${pageSize}&sortBy=startTime&sortDir=desc&_t=${timestamp}`);
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }

                const data = await parseJsonResponse(res);

                // Only update if this is still the latest load
                if (timestamp === loadResultsTimestamp) {
                    resultsTotalPages = data.totalPages || 0;
                    resultsHasMore = resultsPage < resultsTotalPages - 1;
                    
                    // Append or replace data based on reset flag
                    if (reset) {
                        allResultsData = data.content || [];
                    } else {
                        allResultsData = [...allResultsData, ...(data.content || [])];
                    }

                    // Ensure loading row is removed before rendering
                    if (tbody) {
                        const loadingRow = tbody.querySelector('tr td.table-loading');
                        if (loadingRow) {
                            loadingRow.closest('tr').remove();
                        }
                    }

                    // Render the table with all loaded data (append if loading more)
                    renderResultsTable({ content: allResultsData, totalPages: resultsTotalPages }, !reset);
                }
            } catch (e) {
                console.error('Failed to load results:', e);
                // Only show error if this is still the latest load
                if (timestamp === loadResultsTimestamp) {
                    const tbody = document.querySelector('#results-table tbody');
                    if (tbody) {
                        const errorRow = document.createElement('tr');
                        errorRow.innerHTML = '<td colspan="8" class="table-error">Failed to load data: ' + (e.message || 'Unknown error') + '</td>';
                        requestAnimationFrame(() => {
                            tbody.innerHTML = '';
                            tbody.appendChild(errorRow);
                        });
                    }
                }
            } finally {
                if (timestamp === loadResultsTimestamp) {
                    isLoadingResults = false;
                }
            }
        }

        async function loadMoreResults() {
            if (!resultsHasMore || isLoadingResults) return;
            resultsPage++;
            await loadResults(false);
        }

        // Refresh results without resetting scroll or clearing table
        async function refreshResults() {
            if (isLoadingResults) return;
            
            const wrapper = document.querySelector('#results-table')?.closest('.table-wrapper');
            const scrollTop = wrapper ? wrapper.scrollTop : 0;
            
            // Fetch only first page to update existing data
            const originalPage = resultsPage;
            resultsPage = 0;
            
            try {
                const timestamp = Date.now();
                const res = await authenticatedFetch(`/api/v1/database/browse/results?page=0&size=${pageSize}&sortBy=startTime&sortDir=desc&_t=${timestamp}`);
                if (!res.ok) return;
                
                const data = await parseJsonResponse(res);
                const newData = data.content || [];
                
                // Update existing rows in place instead of re-rendering
                updateResultsTableInPlace(newData);
                
                // Restore scroll position
                if (wrapper) {
                    requestAnimationFrame(() => {
                        wrapper.scrollTop = scrollTop;
                    });
                }
            } catch (e) {
                console.error('Failed to refresh results:', e);
            } finally {
                resultsPage = originalPage;
            }
        }

        // Update results table in place without clearing
        function updateResultsTableInPlace(newData) {
            const tbody = document.querySelector('#results-table tbody');
            if (!tbody) return;
            
            // Create a map of new data by ID
            const newDataMap = new Map();
            newData.forEach(r => {
                newDataMap.set(r.id, r);
            });
            
            // Get existing rows
            const existingRows = Array.from(tbody.querySelectorAll('tr[data-result-id]'));
            const existingIds = new Set();
            
            // Update existing rows in place
            existingRows.forEach(row => {
                const id = parseInt(row.dataset.resultId);
                if (!id) return;
                
                existingIds.add(id);
                const newResult = newDataMap.get(id);
                
                if (newResult) {
                    // Update row in place
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 8) {
                        // Update status (cell 3)
                        const statusCell = cells[3];
                        const newStatusBadge = getStatusBadge(newResult.status);
                        if (statusCell.innerHTML !== newStatusBadge) {
                            statusCell.innerHTML = newStatusBadge;
                        }
                        
                        // Update duration (cell 4)
                        const durationCell = cells[4];
                        const newDuration = calculateDuration(newResult.startTime, newResult.endTime, newResult.status);
                        if (durationCell.textContent !== newDuration) {
                            durationCell.textContent = newDuration;
                        }
                        
                        // Update step count (cell 5)
                        const stepCountCell = cells[5];
                        if (stepCountCell.textContent !== String(newResult.stepCount || 0)) {
                            stepCountCell.textContent = newResult.stepCount || 0;
                        }
                    }
                }
            });
            
            // Add new rows that don't exist yet (only if they're in the first page)
            const firstNewId = newData.length > 0 ? newData[0].id : null;
            const lastExistingId = existingRows.length > 0 ? 
                Math.max(...Array.from(existingRows).map(r => parseInt(r.dataset.resultId) || 0)) : 0;
            
            // Only add new rows if they're newer (higher ID) than existing ones
            if (firstNewId && firstNewId > lastExistingId) {
                const fragment = document.createDocumentFragment();
                newData.forEach(r => {
                    if (!existingIds.has(r.id)) {
                        const row = document.createElement('tr');
                        row.dataset.resultId = r.id;
                        const executionIdShort = (r.executionId || '').substring(0, 8);
                        row.innerHTML = `
                            <td><span class="metric-label">#${r.id}</span></td>
                            <td class="table-cell-name-truncate">${escapeHtml(r.testName || '-')}</td>
                            <td><code class="table-cell-code-small">${escapeHtml(executionIdShort)}</code></td>
                            <td>${getStatusBadge(r.status)}</td>
                            <td>${calculateDuration(r.startTime, r.endTime, r.status)}</td>
                            <td>${r.stepCount || 0}</td>
                            <td class="table-cell-time">${formatTimeWithTimezone(r.startTime)}</td>
                            <td class="table-cell-actions">
                                <button class="action-btn btn-primary btn-small" onclick="showJsonModal(${r.id}, event)">JSON</button>
                            </td>
                        `;
                        fragment.appendChild(row);
                    }
                });
                
                // Insert new rows at the top
                if (fragment.children.length > 0) {
                    const firstRow = tbody.querySelector('tr');
                    if (firstRow) {
                        tbody.insertBefore(fragment, firstRow);
                    } else {
                        tbody.appendChild(fragment);
                    }
                }
            }
            
            // Update allResultsData with new data (merge, keeping existing data)
            const existingDataMap = new Map();
            allResultsData.forEach(r => existingDataMap.set(r.id, r));
            
            // Update existing entries and add new ones
            newData.forEach(r => {
                existingDataMap.set(r.id, r);
            });
            
            // Convert back to array, maintaining order (newest first)
            allResultsData = Array.from(existingDataMap.values())
                .sort((a, b) => (b.id || 0) - (a.id || 0));
        }

        function applyResultFilters() {
            // Trim inputs to handle copy-paste with accidental spaces
            const nameFilter = document.getElementById('filter-test-name').value.trim().toLowerCase();
            const statusFilter = document.getElementById('filter-result-status').value;

            // Apply client-side filtering on loaded data
            // Note: This filters only the data already loaded. For full database search,
            // consider implementing server-side filtering in the API.
            const filtered = allResultsData.filter(r => {
                return (!nameFilter || (r.testName || '').toLowerCase().includes(nameFilter)) &&
                       (!statusFilter || r.status === statusFilter);
            });

            renderResultsTable({ content: filtered, totalPages: 1 });
        }

        function renderResultsTable(data, append = false) {
            const tbody = document.querySelector('#results-table tbody');
            if (!tbody) return;
            
            const wrapper = tbody.closest('.table-wrapper');
            const scrollTop = wrapper ? wrapper.scrollTop : 0;
            
            // Remove any loading rows
            const loadingRow = tbody.querySelector('tr td.table-loading');
            if (loadingRow) {
                loadingRow.closest('tr').remove();
            }
            
            totalResultsPages = data.totalPages;

            // Handle empty state
            if (!data.content.length && !append) {
                tbody.innerHTML = '';
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="8" class="table-empty">No results found</td>';
                tbody.appendChild(row);
                const paginationEl = document.getElementById('results-pagination');
                if (paginationEl) paginationEl.innerHTML = '';
                return;
            }
            
            // Get existing row IDs to avoid duplicates when appending
            const existingIds = new Set();
            if (append) {
                Array.from(tbody.querySelectorAll('tr[data-result-id]')).forEach(row => {
                    const id = row.dataset.resultId;
                    if (id) existingIds.add(id);
                });
            } else {
                tbody.innerHTML = '';
            }
            
            // Render rows
            data.content.forEach((r) => {
                // Skip if already rendered (when appending)
                if (append && existingIds.has(String(r.id))) {
                    return;
                }
                
                const row = document.createElement('tr');
                row.dataset.resultId = r.id;
                const executionIdShort = (r.executionId || '').substring(0, 8);
                row.innerHTML = `
                    <td><span class="metric-label">#${r.id}</span></td>
                    <td class="table-cell-name-truncate">${escapeHtml(r.testName || '-')}</td>
                    <td><code class="table-cell-code-small">${escapeHtml(executionIdShort)}</code></td>
                    <td>${getStatusBadge(r.status)}</td>
                    <td>${calculateDuration(r.startTime, r.endTime, r.status)}</td>
                    <td>${r.stepCount || 0}</td>
                    <td class="table-cell-time">${formatTimeWithTimezone(r.startTime)}</td>
                    <td class="table-cell-actions">
                        <button class="action-btn btn-primary btn-small" onclick="showJsonModal(${r.id}, event)">JSON</button>
                    </td>
                `;
                tbody.appendChild(row);
            });
            
            // Hide pagination (using infinite scroll instead)
            const paginationEl = document.getElementById('results-pagination');
            if (paginationEl) paginationEl.innerHTML = '';
            
            // Restore scroll position if we cleared the table
            if (!append && wrapper && scrollTop > 0) {
                requestAnimationFrame(() => {
                    wrapper.scrollTop = scrollTop;
                });
            }
        }

        function paginate(items, page, size) {
            const start = page * size;
            return {
                content: items.slice(start, start + size),
                totalPages: Math.ceil(items.length / size)
            };
        }

        function renderPagination(elId, current, total, callback) {
            const container = document.getElementById(elId);
            if (total <= 1) { container.innerHTML = ''; return; }
            
            let html = `<button class="page-btn" ${current === 0 ? 'disabled' : ''}>â†</button>`;
            html += `<span class="pagination-text">Page ${current + 1} of ${total}</span>`;
            html += `<button class="page-btn" ${current >= total - 1 ? 'disabled' : ''}>â†’</button>`;
            
            container.innerHTML = html;
            container.querySelectorAll('button').forEach((btn, idx) => {
                btn.onclick = () => callback(idx === 0 ? current - 1 : current + 1);
            });
        }

        function getStatusBadge(status) {
            if (!status) return '<span class="badge">UNKNOWN</span>';
            const s = status.toUpperCase();
            if (s === 'PASSED') return '<span class="badge-enhanced status-passed">PASSED</span>';
            if (s === 'FAILED') return '<span class="badge-enhanced status-failed">FAILED</span>';
            if (s === 'RUNNING') return '<span class="badge-enhanced status-running">RUNNING</span>';
            if (s === 'SKIPPED') return '<span class="badge-enhanced status-skipped">SKIPPED</span>';
            return `<span class="badge-enhanced status-unknown">${s}</span>`;
        }

        function formatTime(ts) {
            if (!ts) return '-';
            return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Format time in UTC
        function formatTimeWithTimezone(timestamp) {
            if (!timestamp) return '-';
            const date = new Date(timestamp);
            // Show UTC time
            return date.toLocaleString([], { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit', 
                minute: '2-digit',
                timeZone: 'UTC',
                timeZoneName: 'short'
            });
        }

        function calculateDuration(start, end, status) {
            if (!start) return '-';
            
            // Calculate live duration for running tests
            const endTime = end ? new Date(end) : (status === 'RUNNING' ? new Date() : null);
            
            if (!endTime) return '-'; // If not running and no end time
            
            const diff = endTime - new Date(start);
            if (diff < 0) return '-'; // Invalid time range
            return diff < 1000 ? diff + 'ms' : (diff / 1000).toFixed(1) + 's';
        }

        function renderError(id) {
            document.getElementById(id).innerHTML = `<div class="error-message-inline">Failed to load data</div>`;
        }

        function clearExecutionFilters() {
            document.getElementById('filter-execution-id').value = '';
            document.getElementById('filter-suite-name').value = '';
            document.getElementById('filter-execution-status').value = '';
            selectFilterOption('execution-status', '');
            currentPage = 0;
        }

        function clearResultFilters() {
            document.getElementById('filter-test-name').value = '';
            document.getElementById('filter-result-status').value = '';
            selectFilterOption('result-status', '');
            currentResultsPage = 0;
        }

        // Custom Confirmation Dialog Functions
        let confirmDialogResolve = null;
        let pendingDeleteId = null;

        function showConfirmDialog(title, message) {
            return new Promise((resolve) => {
                confirmDialogResolve = resolve;
                const overlay = document.getElementById('confirm-dialog-overlay');
                const titleEl = document.getElementById('confirm-dialog-title-text');
                const messageEl = document.getElementById('confirm-dialog-message');
                
                titleEl.textContent = title || 'Confirm Action';
                messageEl.textContent = message || 'Are you sure you want to proceed?';
                
                // Lock body scroll when dialog opens
                lockBodyScroll();
                overlay.classList.add('show');
            });
        }

        function closeConfirmDialog(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            const overlay = document.getElementById('confirm-dialog-overlay');
            overlay.classList.remove('show');
            // Unlock body scroll when dialog closes
            unlockBodyScroll();
            if (confirmDialogResolve) {
                confirmDialogResolve(false);
                confirmDialogResolve = null;
            }
        }

        function confirmDialogAction() {
            const overlay = document.getElementById('confirm-dialog-overlay');
            overlay.classList.remove('show');
            // Unlock body scroll when dialog closes
            unlockBodyScroll();
            if (confirmDialogResolve) {
                confirmDialogResolve(true);
                confirmDialogResolve = null;
            }
        }

        // Custom Alert Dialog Functions
        function showAlertDialog(title, message) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('alert-dialog-overlay');
                const titleEl = document.getElementById('alert-dialog-title-text');
                const messageEl = document.getElementById('alert-dialog-message');
                
                titleEl.textContent = title || 'Alert';
                messageEl.textContent = message || '';
                
                // Lock body scroll when dialog opens
                lockBodyScroll();
                overlay.classList.add('show');
                
                // Auto-resolve when OK is clicked
                const okButton = document.getElementById('alert-dialog-ok');
                const originalOnClick = okButton.onclick;
                okButton.onclick = () => {
                    closeAlertDialog();
                    resolve();
                };
            });
        }

        function closeAlertDialog(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            const overlay = document.getElementById('alert-dialog-overlay');
            overlay.classList.remove('show');
            // Unlock body scroll when dialog closes
            unlockBodyScroll();
        }

        async function deleteExecution(id) {
            pendingDeleteId = id;
            const confirmed = await showConfirmDialog(
                'Delete Execution',
                'Are you sure you want to delete this execution record? This action cannot be undone.'
            );
            
            if (!confirmed) {
                pendingDeleteId = null;
                return;
            }
            
            try {
                const res = await authenticatedFetch(`/api/v1/database/executions/${id}`, { method: 'DELETE' });
                const data = await parseJsonResponse(res);
                
                if (data.success) {
                    // Reload executions to reflect the deletion
                    await loadExecutions(true);
                } else {
                    await showAlertDialog('Error', 'Failed to delete execution: ' + (data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error deleting execution:', error);
                await showAlertDialog('Error', 'Failed to delete execution: ' + error.message);
            } finally {
                pendingDeleteId = null;
            }
        }

        // JSON Modal Functions
        // Body scroll lock state
        let bodyScrollLocked = false;
        let originalBodyOverflow = '';
        let originalBodyPaddingRight = '';

        // Enhanced Scroll Lock
        function lockBodyScroll() {
            if (!bodyScrollLocked) {
                // 1. Calculate scrollbar width to prevent layout shift
                const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
                
                // 2. Store original values
                originalBodyOverflow = document.body.style.overflow;
                originalBodyPaddingRight = document.body.style.paddingRight;
                
                // 3. Set padding to replace scrollbar
                document.body.style.paddingRight = `${scrollbarWidth}px`;
                
                // 4. Lock the body
                document.body.style.overflow = 'hidden';
                document.body.classList.add('modal-open'); // Optional hook for CSS
                
                bodyScrollLocked = true;
            }
        }

        function unlockBodyScroll() {
            if (bodyScrollLocked) {
                // 1. Remove lock
                document.body.style.overflow = originalBodyOverflow || '';
                
                // 2. Remove padding
                document.body.style.paddingRight = originalBodyPaddingRight || '';
                document.body.classList.remove('modal-open');
                
                bodyScrollLocked = false;
            }
        }

        function closeJsonModal(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            const overlay = document.getElementById('json-modal-overlay');
            if (overlay) {
                overlay.classList.remove('show');
                unlockBodyScroll();
            }
        }

        // escapeHtml imported from utils/dom.js

        function syntaxHighlight(json) {
            if (typeof json !== 'string') {
                json = JSON.stringify(json, null, 2);
            }
            
            json = escapeHtml(json);
            
            // Highlight JSON syntax
            json = json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
            
            return json;
        }

        async function showJsonModal(resultId, event) {
            const overlay = document.getElementById('json-modal-overlay');
            const content = document.getElementById('json-modal-content');
            
            // Lock body scroll when modal opens
            lockBodyScroll();
            overlay.classList.add('show');
            content.innerHTML = '<div class="json-loading">Loading JSON data...</div>';
            
            try {
                const res = await authenticatedFetch(`/api/v1/database/results/${resultId}?_t=${Date.now()}`);
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                
                const data = await parseJsonResponse(res);
                
                // Truncate large JSON payloads to prevent UI freeze
                const MAX_LENGTH = 50000; // 50KB limit
                let jsonStr = JSON.stringify(data, null, 2);
                let isTruncated = false;
                
                if (jsonStr.length > MAX_LENGTH) {
                    jsonStr = jsonStr.substring(0, MAX_LENGTH) + '\n\n... [TRUNCATED DUE TO SIZE - ' + (jsonStr.length - MAX_LENGTH).toLocaleString() + ' characters omitted] ...';
                    isTruncated = true;
                }
                
                const formattedJson = syntaxHighlight(jsonStr);
                let html = `<div class="json-content">${formattedJson}</div>`;
                
                if (isTruncated) {
                    html += '<div style="padding: 12px; background: rgba(245, 158, 11, 0.1); border-top: 1px solid rgba(245, 158, 11, 0.3); color: var(--accent-warning); font-size: 12px;">âš ï¸ Large payload truncated for performance. Full data available via API.</div>';
                }
                
                content.innerHTML = html;
            } catch (error) {
                console.error('Failed to load JSON:', error);
                content.innerHTML = `<div class="json-error">Failed to load JSON data: ${error.message}</div>`;
            }
        }

        // Copy JSON to clipboard
        function copyJson(event) {
            const content = document.querySelector('.json-content');
            if (content) {
                // Get plain text without HTML tags
                const textToCopy = content.innerText || content.textContent;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    // Show temporary feedback
                    const button = event ? event.target.closest('button') : document.querySelector('.json-modal-header button');
                    if (button) {
                        const originalText = button.innerHTML;
                        button.innerHTML = '<svg class="icon" viewBox="0 0 24 24" style="width: 14px; height: 14px;"><polyline points="20 6 9 17 4 12"/></svg>Copied!';
                        button.style.color = 'var(--accent-success)';
                        setTimeout(() => {
                            button.innerHTML = originalText;
                            button.style.color = '';
                        }, 2000);
                    }
                }).catch(async err => {
                    console.error('Failed to copy JSON:', err);
                    await showAlertDialog('Error', 'Failed to copy JSON to clipboard');
                });
            }
        }

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const jsonOverlay = document.getElementById('json-modal-overlay');
                const confirmOverlay = document.getElementById('confirm-dialog-overlay');
                const alertOverlay = document.getElementById('alert-dialog-overlay');
                
                if (jsonOverlay && jsonOverlay.classList.contains('show')) {
                    closeJsonModal();
                } else if (confirmOverlay && confirmOverlay.classList.contains('show')) {
                    closeConfirmDialog();
                } else if (alertOverlay && alertOverlay.classList.contains('show')) {
                    closeAlertDialog();
                }
            }
        });

        // Expose dropdown functions to global scope for inline onclick handlers
        // Must be after all function definitions
        window.toggleDropdown = toggleDropdown;
        window.selectRefreshOption = selectRefreshOption;
        window.selectFilterOption = selectFilterOption;
        window.handleDropdownKeydown = handleDropdownKeydown;
        window.handleDropdownOptionKeydown = handleDropdownOptionKeydown;
        window.clearExecutionFilters = clearExecutionFilters;
        window.clearResultFilters = clearResultFilters;
        window.updateAutoRefresh = updateAutoRefresh;
        window.deleteExecution = deleteExecution;
        window.showJsonModal = showJsonModal;
        window.closeJsonModal = closeJsonModal;
        window.copyJson = copyJson;
        window.showConfirmDialog = showConfirmDialog;
        window.closeConfirmDialog = closeConfirmDialog;
        window.confirmDialogAction = confirmDialogAction;
        window.showAlertDialog = showAlertDialog;
        window.closeAlertDialog = closeAlertDialog;
    </script>
</body>
</html>